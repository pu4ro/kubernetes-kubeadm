---
# Basic Kubernetes Cluster Configuration

# Kubernetes Version Configuration
# Supported Kubernetes versions:
#   - k8s 1.27.x and below: Uses kubeadm v1beta3 API
#   - k8s 1.28.x - 1.30.x: Can use v1beta3 or v1beta4 API
#   - k8s 1.31.x and above: Requires kubeadm v1beta4 API (configured in templates)
#
# This playbook uses v1beta4 API format and is optimized for k8s 1.31+
# Key changes in 1.31+:
#   - kubeadm config: v1beta3 â†’ v1beta4 (InitConfiguration + ClusterConfiguration)
#   - kube-vip: Uses super-admin.conf instead of admin.conf
#   - API server extraArgs: Changed from map to list format (name/value pairs)
#
kubernetes_version: '1.34.1'        # Recommended: 1.31.x or higher for full feature support
dns_domain: cluster.local
service_subnet: 10.96.0.0/12
pod_subnet: 10.244.0.0/16

# High Availability Settings (for multi-master setup)
master_ha: true
kube_vip_port: 6443
kube_vip_interface: ens18
kube_vip_address: 192.168.135.69  # Uncomment for HA setup

# Container Runtime Configuration
# Supported containerd versions:
#   - containerd 1.6.x - 1.7.x: Config version 2 format (deprecated but supported)
#   - containerd 2.0.x - 2.1.x: Config version 2 format with new plugin structure
#   - containerd 2.2.x+: Config version 3 format (new pinned_images structure)
#
# The playbook automatically detects the installed containerd version and applies
# the appropriate configuration format. Both old and new formats are supported.
#
# Configuration differences by version:
#   < 2.2: Uses sandbox_image for pause container, old plugin paths
#   >= 2.2: Uses pinned_images.sandbox, new io.containerd.cri.v1.* plugins
#
containerd_version: "1.7.6"         # Reference only (auto-detected at runtime)
containerd_limit_nproc: 100000      # systemd LimitNPROC for containerd.service
containerd_limit_nofile: 100000     # systemd LimitNOFILE for containerd.service
enable_local_registry: false
local_registry_image: "registry:2"
local_registry_image_tar: "/root/docker.tar.gz"
local_registry_container_name: "local-registry"
local_registry_host_port: 80
local_registry_container_port: 5000
local_registry_data_dir: "/opt/local-registry/data"
local_registry_additional_args: []

# Containerd Data Directory Configuration
# Set custom data directory for containerd (default: /var/lib/containerd)
# The actual path will be: {containerd_data_base_dir}/{hostname}
# Example: /data/containerd/worker1, /data/containerd/worker2
# Leave empty or comment out to use default /var/lib/containerd
containerd_data_base_dir: ""  # Base directory for containerd data
# containerd_data_base_dir: ""  # Use this to disable custom path and use default

# System Configuration
set_timezone: Asia/Seoul
configure_etc_hosts: true
set_hostname_from_inventory: true

# NTP/Chrony Configuration
use_local_ntp: true                    # true: master1 as NTP server, true: use external NTP
external_ntp_servers: {}             # External NTP servers
  #  - "pool.ntp.org"
  #  - "time.google.com"
  #  - "time.cloudflare.com"
cluster_network: "192.168.0.0/16"     # Network range allowed to access local NTP server

# Cross-platform service and config paths
chrony_service_name: "{{ 'chronyd' if ansible_os_family == 'RedHat' else 'chrony' }}"
chrony_config_path: "{{ '/etc/chrony.conf' if ansible_os_family == 'RedHat' else '/etc/chrony/chrony.conf' }}"

# Network Plugin (flannel is default)
network_plugin: "flannel"

# Master Node Scheduling (allow pods on master for single-node setup)
allow_master_scheduling: true

# Certificate Extension (extend certificates to 10 years)
extend_k8s_certificates: true

# Parallel Execution Control
# Set how many hosts to run simultaneously during installation
# 1 = sequential (one at a time), 0 = all hosts in parallel
parallel_execution:
  system_preparation: 0     # How many hosts for system prep phase (packages, containerd)
  package_installation: 0   # How many hosts for apt/yum operations simultaneously
  kubernetes_installation: 0  # How many hosts for kubernetes installation (0 = all parallel)

# Example configurations:
# For fast installation on reliable network (all parallel):
# parallel_execution:
#   system_preparation: 0
#   package_installation: 0  
#   kubernetes_installation: 0
#
# For mixed approach (packages sequential, k8s parallel):
# parallel_execution:
#   system_preparation: 1
#   package_installation: 1
#   kubernetes_installation: 0
#
# For completely sequential installation:
# parallel_execution:
#   system_preparation: 1
#   package_installation: 1
#   kubernetes_installation: 1

# Package Repository URLs (for offline installation)
repo_url:
  centos: "http://192.168.1.10:8080/repo/"
  ubuntu: "http://192.168.134.102/ubuntu_22.04.5"

# Ubuntu APT Repository Configuration
# Enable this to use custom Ubuntu repository (local or HTTP)
# Example: Apache HTTP server serving local packages
enable_ubuntu_repo: false
ubuntu_repo_url: ""  # Example: "http://192.168.1.100:8080/ubuntu-repo"
ubuntu_repo_components: "./"
ubuntu_repo_trusted: true
ubuntu_repo_update_cache: true

# RHEL/CentOS YUM Repository Configuration (supports multiple repositories)
# Enable this to use custom RHEL repositories (local or HTTP)
# You can configure multiple repositories with different priorities
#
# Usage:
#   ansible-playbook site.yml --tags rhel-repo
#
enable_rhel_repos: true
rhel_repos:
  - name: "rhel-iso-repo"
    id: "rhel-iso-repo"
    url: "http://192.168.135.71:8080/rhel-repo"
    type: "baseos_appstream"  # Options: "single" or "baseos_appstream"
    enabled: 1
    gpgcheck: 0
    priority: 1
  # Example: Directory-based repository
  - name: "rhel-directory-repo"
    id: "rhel-directory-repo"
    url: "http://192.168.135.71:8080/rhel-repo2"
    type: "single"
    enabled: 1
    gpgcheck: 0
    priority: 2
  # Add more repositories as needed
  # - name: "custom-repo"
  #   id: "custom-repo"
  #   url: "http://192.168.135.72:8080/custom-repo/"
  #   type: "single"
  #   enabled: 1
  #   gpgcheck: 0
  #   priority: 3

# Container Registry Settings (basic Docker configuration)
insecure_registries: []
  #- "192.168.1.10:5000"           # Local registry example
  # - "harbor.yourdomain.com"     # Harbor registry example
  # - "registry.local"            # Custom registry example
docker_log_max_size: "100m"

# Containerd Registry Authentication Configuration
# Configure authentication for registries in containerd config.toml
# This complements docker_registries (used for nerdctl login)
#
# Usage:
#   ansible-playbook site.yml --tags containerd-config
#
containerd_registry_auth:
  # Example configurations:
  - registry: "registry.test"
    insecure_skip_verify: true
    username: ""          # Leave empty for no auth
    password: ""
    auth: ""
    identitytoken: ""
  - registry: "registry.local"
    insecure_skip_verify: true
    username: ""
    password: ""
    auth: ""
    identitytoken: ""
  # - registry: "cr.makina.rocks"
  #   insecure_skip_verify: false
  #   username: "your-username"
  #   password: "your-password"
  #   auth: ""              # Optional: base64 encoded username:password
  #   identitytoken: ""     # Optional: for token-based auth
  # - registry: "harbor.yourdomain.com"
  #   insecure_skip_verify: true
  #   username: "admin"
  #   password: "Harbor12345"
  #   auth: ""
  #   identitytoken: ""

# Kubernetes Pause Container Image
# Pause container versions by Kubernetes version:
#   - k8s 1.26.x and below: pause:3.9
#   - k8s 1.27.x - 1.30.x: pause:3.9 or 3.10
#   - k8s 1.31.x and above: pause:3.10 or 3.10.1 (recommended)
#
# The pause container is the infrastructure container that holds network namespaces
# for all pods. It's configured differently based on containerd version:
#   - containerd < 2.2: Set via sandbox_image in config.toml
#   - containerd >= 2.2: Set via pinned_images.sandbox in config.toml (version 3 format)
#
pause_image: "cr.makina.rocks/external-hub/kubernetes/pause:3.10.1"

# NVIDIA runtime support for containerd
# GPU will be auto-detected via lspci, no manual configuration needed
# No driver installation by Ansible - install NVIDIA Container Toolkit separately

# Docker Registry Credentials Configuration
# Set docker_login_required to true to enable registry authentication
# Supports multiple registries with different protocols (http/https)
# 
# Usage with tags:
#   ansible-playbook site.yml --tags docker-credentials        # Full setup
#   ansible-playbook site.yml --tags nerdctl-login            # Login only
#   ansible-playbook site.yml --tags containerd-config        # Config only
#   ansible-playbook site.yml --tags restart-kubelet          # Restart only
#
docker_login_required: true
docker_registries:
  # Example configuration for multiple registries:
  - registry: "cr.makina.rocks"
    protocol: "https"  # https (default) or http
    username: "mrx.dev"
    password: "GMflzHdAeR3KhGgXoecXR3lTKO0lSX5O"
  - registry: "harbor.runway.test"
    protocol: "http"   # for insecure registries
    username: "admin" 
    password: "Harbor12345"
  # - registry: "gcr.io"
  #   protocol: "https"
  #   username: "_json_key"
  #   password: "{{ gcp_service_account_key }}"

# Registry Host Mapping (for /etc/hosts configuration)
# Map registry domains to their IP addresses
# This will be added to /etc/hosts along with inventory host information
# 
# Usage with tags:
#   ansible-playbook site.yml --tags hosts-config    # Update /etc/hosts only
#   ansible-playbook site.yml --tags common          # Full common setup
#
registry_hosts:
  "harbor.runway.test": "192.168.135.28"
  # Add more registry domains and their IPs as needed

# CoreDNS Hosts Configuration (add registry hosts to CoreDNS)
configure_coredns_hosts: true

# ansible-playbook -i inventory.ini site.yml --tags coredns-hosts -e
