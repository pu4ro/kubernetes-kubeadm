---
# Phase 1: Remove conflicting packages (RHEL/CentOS only)
- name: Remove conflicting container packages (podman, buildah, runc)
  yum:
    name:
      - podman
      - buildah
      - runc
      - podman-catatonit
      - cockpit-podman
      - podman-plugins
      - podman-gvproxy
    state: absent
  when: ansible_os_family == "RedHat"
  ignore_errors: yes
  tags: ['base', 'container']

# Phase 2: Install containerd package
- name: Install containerd package (Ubuntu/Debian)
  apt:
    name: containerd
    state: present
    update_cache: yes
  when: ansible_os_family == "Debian"
  register: containerd_install_ubuntu

- name: Install containerd.io package (RHEL 8)
  yum:
    name: containerd.io-1.6.32-3.1.el8
    state: present
  when: 
    - ansible_os_family == "RedHat"
    - ansible_distribution_major_version == "8"
  register: containerd_install_rhel8

- name: Install containerd.io package (RHEL 9)
  yum:
    name: containerd.io
    state: present
  when: 
    - ansible_os_family == "RedHat"
    - ansible_distribution_major_version == "9"
  register: containerd_install_rhel9

# RHEL-specific systemd service limits configuration
- name: Ensure LimitNPROC is set to 100000 (RHEL/CentOS only)
  lineinfile:
    path: /usr/lib/systemd/system/containerd.service
    regexp: '^LimitNPROC='
    line: "LimitNPROC={{ containerd_limit_nproc | default(100000) }}"
    state: present
    insertafter: '^\[Service\]'
  when: ansible_os_family == "RedHat"

- name: Ensure LimitNOFILE is set to 100000 (RHEL/CentOS only)
  lineinfile:
    path: /usr/lib/systemd/system/containerd.service
    regexp: '^LimitNOFILE='
    line: "LimitNOFILE={{ containerd_limit_nofile | default(100000) }}"
    state: present
    insertafter: '^\[Service\]'
  when: ansible_os_family == "RedHat"

- name: Create containerd configuration directory
  file:
    path: /etc/containerd
    state: directory
    mode: '0755'

- name: Create custom containerd data directory
  file:
    path: "{{ containerd_data_base_dir }}/{{ inventory_hostname }}"
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: containerd_data_base_dir is defined and containerd_data_base_dir != ''

- name: Display containerd data directory
  debug:
    msg: "Containerd data directory: {{ containerd_data_base_dir | default('/var/lib/containerd') }}{% if containerd_data_base_dir | default('') != '' %}/{{ inventory_hostname }}{% endif %}"

- name: Display containerd configuration mode
  debug:
    msg: "Configuring containerd with {{ 'NVIDIA GPU' if (has_nvidia_gpu | default(false) | bool) else 'standard' }} runtime (auto-detected)"

- name: Remove existing containerd config.toml (force clean state)
  file:
    path: /etc/containerd/config.toml
    state: absent

# Generate default containerd configuration
- name: Generate default containerd configuration
  shell: containerd config default > /etc/containerd/config.toml
  args:
    creates: /etc/containerd/config.toml

# Step 1: Enable SystemdCgroup
- name: Enable SystemdCgroup in containerd config
  replace:
    path: /etc/containerd/config.toml
    regexp: 'SystemdCgroup = false'
    replace: 'SystemdCgroup = true'
  notify: restart containerd

# Step 2: Configure custom root path (if specified)
- name: Set custom containerd root path
  lineinfile:
    path: /etc/containerd/config.toml
    regexp: '^root = '
    line: 'root = "{{ containerd_data_base_dir }}/{{ inventory_hostname }}"'
    state: present
  when: containerd_data_base_dir is defined and containerd_data_base_dir != ''
  notify: restart containerd

# Step 3: Configure pause image
- name: Set custom pause image (sandbox_image)
  replace:
    path: /etc/containerd/config.toml
    regexp: 'sandbox_image = ".*?"'
    replace: 'sandbox_image = "{{ pause_image }}"'
  notify: restart containerd

# Step 4: Add NVIDIA runtime configuration (if GPU detected)
- name: Add NVIDIA runtime to containerd config
  blockinfile:
    path: /etc/containerd/config.toml
    marker: "        # {mark} ANSIBLE MANAGED - NVIDIA RUNTIME"
    insertafter: '^\s+\[plugins\."io\.containerd\.grpc\.v1\.cri"\.containerd\.runtimes\.runc\.options\]'
    block: |2
              
              [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.nvidia]
                runtime_type = "io.containerd.runc.v2"
                [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.nvidia.options]
                  BinaryName = "/usr/bin/nvidia-container-runtime"
                  SystemdCgroup = true
    state: present
  when: has_nvidia_gpu | default(false) | bool
  notify: restart containerd

# Step 5: Set default runtime to nvidia (if GPU detected)
- name: Set default runtime to nvidia
  replace:
    path: /etc/containerd/config.toml
    regexp: 'default_runtime_name = "runc"'
    replace: 'default_runtime_name = "nvidia"'
  when: has_nvidia_gpu | default(false) | bool
  notify: restart containerd

# Step 6: Configure registry mirrors (if insecure_registries is defined)
- name: Add registry mirrors configuration
  blockinfile:
    path: /etc/containerd/config.toml
    marker: "      # {mark} ANSIBLE MANAGED - REGISTRY MIRRORS"
    insertafter: '^\s+\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\.mirrors\]'
    block: |
      {% if containerd_registry_auth is defined and containerd_registry_auth | length > 0 %}
      {% for registry_config in containerd_registry_auth %}
      {% if registry_config.insecure_skip_verify | default(true) %}
            [plugins."io.containerd.grpc.v1.cri".registry.mirrors."{{ registry_config.registry }}"]
              endpoint = ["http://{{ registry_config.registry }}"]
      {% else %}
            [plugins."io.containerd.grpc.v1.cri".registry.mirrors."{{ registry_config.registry }}"]
              endpoint = ["https://{{ registry_config.registry }}"]
      {% endif %}
      {% endfor %}
      {% elif insecure_registries is defined and insecure_registries | length > 0 %}
      {% for registry in insecure_registries | unique %}
            [plugins."io.containerd.grpc.v1.cri".registry.mirrors."{{ registry }}"]
              endpoint = ["http://{{ registry }}"]
      {% endfor %}
      {% endif %}
    state: present
  when: 
    - (containerd_registry_auth is defined and containerd_registry_auth | length > 0) or
      (insecure_registries is defined and insecure_registries | length > 0)
  notify: restart containerd

# Step 7: Configure registry authentication (if defined)
- name: Add registry authentication configuration
  blockinfile:
    path: /etc/containerd/config.toml
    marker: "      # {mark} ANSIBLE MANAGED - REGISTRY AUTH"
    insertafter: '^\s+\[plugins\."io\.containerd\.grpc\.v1\.cri"\.registry\.configs\]'
    block: |
      {% if containerd_registry_auth is defined and containerd_registry_auth | length > 0 %}
      {% for registry_config in containerd_registry_auth %}
            [plugins."io.containerd.grpc.v1.cri".registry.configs."{{ registry_config.registry }}".tls]
              insecure_skip_verify = {{ registry_config.insecure_skip_verify | default(true) | lower }}
            [plugins."io.containerd.grpc.v1.cri".registry.configs."{{ registry_config.registry }}".auth]
              username = "{{ registry_config.username | default('') }}"
              password = "{{ registry_config.password | default('') }}"
              auth = "{{ registry_config.auth | default('') }}"
              identitytoken = "{{ registry_config.identitytoken | default('') }}"
      {% endfor %}
      {% elif insecure_registries is defined and insecure_registries | length > 0 %}
      {% for registry in insecure_registries | unique %}
            [plugins."io.containerd.grpc.v1.cri".registry.configs."{{ registry }}".tls]
              insecure_skip_verify = true
            [plugins."io.containerd.grpc.v1.cri".registry.configs."{{ registry }}".auth]
              username = ""
              password = ""
              auth = ""
              identitytoken = ""
      {% endfor %}
      {% endif %}
    state: present
  when: 
    - (containerd_registry_auth is defined and containerd_registry_auth | length > 0) or
      (insecure_registries is defined and insecure_registries | length > 0)
  notify: restart containerd

- name: Reload systemd daemon (RHEL/CentOS after service file changes)
  systemd:
    daemon_reload: yes
  when: ansible_os_family == "RedHat"

- name: Start and enable containerd service
  systemd:
    name: containerd
    state: started
    enabled: yes

- name: Set CONTAINERD_NAMESPACE environment variable globally
  lineinfile:
    path: /etc/environment
    regexp: '^CONTAINERD_NAMESPACE='
    line: 'CONTAINERD_NAMESPACE=k8s.io'
    state: present
    create: yes

- name: Set CONTAINERD_NAMESPACE for current session
  lineinfile:
    path: /etc/profile.d/containerd.sh
    line: 'export CONTAINERD_NAMESPACE=k8s.io'
    state: present
    create: yes
    mode: '0644'

- name: Set CONTAINERD_NAMESPACE in bashrc for root user
  lineinfile:
    path: /root/.bashrc
    regexp: '^export CONTAINERD_NAMESPACE='
    line: 'export CONTAINERD_NAMESPACE=k8s.io'
    state: present

- name: Wait for containerd socket to be ready
  wait_for:
    path: /run/containerd/containerd.sock
    timeout: 30

# Insecure Registry Configuration (certs.d method)
- name: Configure insecure registries using certs.d method
  block:
    - name: Create certs.d directory for each insecure registry
      file:
        path: "/etc/containerd/certs.d/{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop: "{{ insecure_registries | default([]) }}"
      when: insecure_registries is defined and insecure_registries | length > 0

    - name: Create hosts.toml for each insecure registry
      copy:
        dest: "/etc/containerd/certs.d/{{ item }}/hosts.toml"
        content: |
          server = "http://{{ item }}"

          [host."http://{{ item }}"]
            skip_verify = false
            capabilities = ["pull", "resolve", "push"]
        owner: root
        group: root
        mode: '0644'
      loop: "{{ insecure_registries | default([]) }}"
      when: insecure_registries is defined and insecure_registries | length > 0
      notify: restart containerd

    - name: Restart containerd and kubelet after registry configuration
      systemd:
        name: "{{ item }}"
        state: restarted
      loop:
        - containerd
        - kubelet
      when:
        - insecure_registries is defined and insecure_registries | length > 0
      ignore_errors: yes  # kubelet may not be installed yet
  when: insecure_registries is defined and insecure_registries | length > 0
  tags: ['container', 'insecure-registry']

# Phase 2: Install nerdctl package (after containerd is ready)
- name: Install nerdctl package (Ubuntu/Debian)
  apt:
    name: nerdctl
    state: present
  when: 
    - ansible_os_family == "Debian"
    - containerd_install_ubuntu is succeeded
  register: nerdctl_install_ubuntu

- name: Install nerdctl package (RHEL/CentOS)
  yum:
    name: nerdctl
    state: present
  when: 
    - ansible_os_family == "RedHat"
    - (containerd_install_rhel8 is succeeded) or (containerd_install_rhel9 is succeeded)
  register: nerdctl_install_rhel

- name: Verify nerdctl installation
  command: nerdctl --version
  register: nerdctl_version_check
  changed_when: false
  when: (nerdctl_install_ubuntu is succeeded) or (nerdctl_install_rhel is succeeded)

# Phase 3: Install buildkit package (after nerdctl is ready)
- name: Install buildkit package (Ubuntu/Debian)
  apt:
    name: buildkit
    state: present
  when: 
    - ansible_os_family == "Debian"
    - nerdctl_version_check is succeeded
  register: buildkit_install_ubuntu

- name: Install buildkit package (RHEL/CentOS)
  yum:
    name: buildkit
    state: present
  when: 
    - ansible_os_family == "RedHat"
    - nerdctl_version_check is succeeded
  register: buildkit_install_rhel

- name: Create buildkit configuration directory
  file:
    path: /etc/buildkit
    state: directory
    mode: '0755'
  when: (buildkit_install_ubuntu is succeeded) or (buildkit_install_rhel is succeeded)

- name: Create buildkitd configuration
  copy:
    dest: /etc/buildkit/buildkitd.toml
    content: |
      [worker.oci]
        enabled = false
      [worker.containerd]
        enabled = true
        namespace = "k8s.io"
    owner: root
    group: root
    mode: '0644'
  when: (buildkit_install_ubuntu is succeeded) or (buildkit_install_rhel is succeeded)

- name: Start and enable buildkit service
  systemd:
    name: buildkit
    state: started
    enabled: yes
  when: (buildkit_install_ubuntu is succeeded) or (buildkit_install_rhel is succeeded)

# Final verification
- name: Test containerd functionality
  command: nerdctl images
  register: containerd_test
  changed_when: false
  failed_when: false

- name: Display installation status
  debug:
    msg: |
      Installation completed:
      - containerd: {{ 'INSTALLED' if (containerd_install_ubuntu is succeeded) or (containerd_install_rhel is succeeded) else 'FAILED' }}
      - nerdctl: {{ 'INSTALLED' if nerdctl_version_check is succeeded else 'FAILED' }}
      - buildkit: {{ 'INSTALLED' if (buildkit_install_ubuntu is succeeded) or (buildkit_install_rhel is succeeded) else 'FAILED' }}
      - Test: {{ 'PASSED' if containerd_test.rc == 0 else 'FAILED' }}
