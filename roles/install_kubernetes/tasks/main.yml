- name: Initialize the Kubernetes master
  block:
    - name: Start kubelet service
      service:
        name: kubelet
        state: started
        enabled: yes
      
    - name: Check if any Kubernetes nodes are already set up
      command: kubectl get nodes
      register: kubectl_nodes
      ignore_errors: true

    - name: Template kubeadm config file
      template:
        src: kubeadm-init.yaml.j2
        dest: /root/kubeadm-init.yml

    - name: Create /etc/kubernetes/manifests directory
      file:
        path: /etc/kubernetes/manifests
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Remove kube-vip manifest file when HA is disabled
      file:
        path: /etc/kubernetes/manifests/kube-vip.yaml
        state: absent
      when: not master_ha and inventory_hostname in groups['masters']

    - name: Template kube-vip manifest file for first master only (before init)
      template:
        src: kube-vip.yaml.j2
        dest: /etc/kubernetes/manifests/kube-vip.yaml
      when: master_ha and kube_vip_address is defined and inventory_hostname == groups['masters'][0]

    - name: Initialize Kubernetes cluster with kubeadm (single master)
      command: kubeadm init --config=/root/kubeadm-init.yml
      when: inventory_hostname in groups['masters'] and kubectl_nodes.rc != 0 and not master_ha

    - name: Initialize Kubernetes cluster with kubeadm (HA master)
      command: kubeadm init --config=/root/kubeadm-init.yml --upload-certs
      register: kubeadm_init
      when: inventory_hostname == groups['masters'][0] and kubectl_nodes.rc != 0 and master_ha
      delegate_to: "{{ groups['masters'][0] }}"
      run_once: true

    - name: Create .kube directory
      file:
        path: "{{ ansible_env.HOME }}/.kube"
        state: directory
        mode: 0755
      when: inventory_hostname in groups['masters'] and kubectl_nodes.rc != 0

    - name: Copy admin kubeconfig to user's home directory
      become: true
      copy:
        src: "/etc/kubernetes/admin.conf"
        dest: "{{ ansible_env.HOME }}/.kube/config"
        remote_src: yes
        mode: 0644
      delegate_to: "{{ groups['masters'][0] }}"
      when: inventory_hostname in groups['masters'] and kubectl_nodes.rc != 0

    - name: Generate kubeadm token on first master node
      shell: kubeadm token create
      register: kubeadm_token
      when: master_ha and inventory_hostname == groups['masters'][0]

    - name: Get discovery token CA cert hash on first master node
      shell: openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256
      register: discovery_token_ca_cert_hash
      when: master_ha and inventory_hostname == groups['masters'][0]

    - name: Generate certificate key on first master node
      shell: kubeadm init phase upload-certs --upload-certs
      register: certificate_key_output
      when: master_ha and inventory_hostname == groups['masters'][0]

    - name: Extract certificate key on first master node
      set_fact:
        certificate_key: "{{ certificate_key_output.stdout_lines[-1] }}"
      when: master_ha and inventory_hostname == groups['masters'][0]

    - name: Extract discovery token CA cert hash value
      set_fact:
        discovery_token_ca_cert_hash_value: "{{ discovery_token_ca_cert_hash.stdout.split('=')[-1].strip() }}"
      when: master_ha and inventory_hostname == groups['masters'][0]

    - name: Wait for API server to be ready on first master
      wait_for:
        host: "{{ kube_vip_address }}"
        port: "{{ kube_vip_port }}"
        state: started
        delay: 5
        timeout: 30
      when: master_ha and inventory_hostname in groups['masters'][1:3]

    - name: Wait for etcd to stabilize before joining additional masters
      pause:
        seconds: 30
      when: master_ha and inventory_hostname in groups['masters'][1:3]

    - name: Wait for previous master to be ready (master2 waits for master1, master3 waits for master2)
      shell: |
        previous_ready="$(kubectl get node {{ groups['masters'][groups['masters'].index(inventory_hostname) - 1] }} \
          -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || true)"
        if [ "$previous_ready" = "True" ]; then
          echo "Ready"
        elif kubectl get --raw /readyz 2>/dev/null | grep -q "ok"; then
          echo "ApiReady"
        else
          echo "Waiting"
        fi
      args:
        executable: /bin/bash
      register: previous_master_ready
      delegate_to: "{{ groups['masters'][0] }}"
      until: previous_master_ready.stdout in ["Ready", "ApiReady"]
      retries: 20
      delay: 15
      when:
        - master_ha
        - inventory_hostname in groups['masters'][1:3]
        - groups['masters'].index(inventory_hostname) > 0
      ignore_errors: yes

    - name: Join the node to the Kubernetes cluster
      block:
        - name: Execute kubeadm join for additional masters
          shell: |
            kubeadm join {{ kube_vip_address }}:{{ kube_vip_port }} --token {{ hostvars[groups['masters'][0]].kubeadm_token.stdout }} \
              --discovery-token-ca-cert-hash sha256:{{ hostvars[groups['masters'][0]].discovery_token_ca_cert_hash_value }} \
              --control-plane --certificate-key {{ hostvars[groups['masters'][0]].certificate_key }}
          register: join_output
          until: join_output.rc == 0 or 'already exists' in join_output.stderr or 'already a member' in join_output.stderr
          retries: 5
          delay: 30
          failed_when: join_output.rc != 0 and 'already exists' not in join_output.stderr and 'already a member' not in join_output.stderr

        - name: Display join command output
          debug:
            var: join_output.stdout

        - name: Wait for node registration after join
          shell: |
            readiness="$(kubectl get node {{ inventory_hostname }} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || true)"
            case "$readiness" in
              True) echo "Ready" ;;
              False|Unknown) echo "Registered" ;;
              *) echo "Waiting" ;;
            esac
          args:
            executable: /bin/bash
          register: node_ready
          delegate_to: "{{ groups['masters'][0] }}"
          until: node_ready.stdout in ["Ready", "Registered"]
          retries: 20
          delay: 10

        - name: Deploy kube-vip manifest after successful join
          template:
            src: kube-vip.yaml.j2
            dest: /etc/kubernetes/manifests/kube-vip.yaml
          when: join_output.rc == 0

      rescue:
        - name: Clean up kube-vip manifest on join failure
          file:
            path: /etc/kubernetes/manifests/kube-vip.yaml
            state: absent

        - name: Remove VIP from interface if incorrectly bound
          command: ip addr del {{ kube_vip_address }}/32 dev {{ kube_vip_interface }}
          ignore_errors: yes

        - name: Reset node after join failure
          command: kubeadm reset -f

        - name: Fail with clear message
          fail:
            msg: "Failed to join master node {{ inventory_hostname }} to the cluster after multiple retries"

      when: master_ha and inventory_hostname in groups['masters'][1:3]

    - name: Copy admin kubeconfig to user's home directory
      become: true
      copy:
        src: "/etc/kubernetes/admin.conf"
        dest: "{{ ansible_env.HOME }}/.kube/config"
        remote_src: yes
        mode: 0644
      when: master_ha and inventory_hostname in groups['masters'] and kubectl_nodes.rc != 0

    - name: Get kubeadm join command
      command: kubeadm token create --print-join-command
      register: join_command
      changed_when: False
      when: inventory_hostname in groups['masters'] 
      delegate_to: "{{ groups['masters'][0] }}"
      
    - name: Set join command as fact
      set_fact:
        join_cmd: "{{ join_command.stdout }}"
      when: inventory_hostname in groups['masters'] 
      delegate_to: "{{ groups['masters'][0] }}"
      run_once: true 


- name: Check if the node is already part of the cluster
  stat:
    path: /etc/kubernetes/kubelet.conf
  register: node_already_joined
  when: inventory_hostname in groups['workers']

- name: Join the Kubernetes worker nodes
  command: "{{ hostvars[groups['masters'][0]]['join_cmd'] }}"
  when: inventory_hostname in groups['workers'] and not node_already_joined.stat.exists
  register: join_result
  until: join_result.rc == 0 or 'already exists' in join_result.stderr
  retries: 3
  delay: 30
  failed_when: join_result.rc != 0 and 'already exists' not in join_result.stderr

- name: Verify node joined successfully
  command: kubectl get nodes {{ inventory_hostname }}
  delegate_to: "{{ groups['masters'][0] }}"
  when: inventory_hostname in groups['workers'] and join_result is defined and join_result.rc == 0
  retries: 5
  delay: 10

- name: Configure comprehensive PATH in bashrc
  blockinfile:
    path: "{{ ansible_env.HOME }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED - Kubernetes environment PATH"
    block: |
      export PATH="/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin:$PATH"
    create: yes
  when: inventory_hostname in groups['masters']

- name: Configure kubectl completion and aliases in bashrc
  blockinfile:
    path: "{{ ansible_env.HOME }}/.bashrc"
    marker: "# {mark} ANSIBLE MANAGED - Kubernetes aliases"
    block: |
      # kubectl completion
      if [ -f /etc/bash_completion.d/kubectl ]; then
        source /etc/bash_completion.d/kubectl
      fi

      # kubectl aliases
      alias k=kubectl
      alias kgp='kubectl get pods'
      alias kgs='kubectl get svc'
      alias kgn='kubectl get nodes'
      alias kga='kubectl get all'
      alias kgpa='kubectl get pods -A'
      complete -F __start_kubectl k
    create: yes
  when: inventory_hostname in groups['masters']

- name: Install kubectl completion
  shell: kubectl completion bash > /etc/bash_completion.d/kubectl
  args:
    creates: /etc/bash_completion.d/kubectl
  when: inventory_hostname in groups['masters']
  ignore_errors: yes

- name: Configure comprehensive PATH in root bashrc
  blockinfile:
    path: /root/.bashrc
    marker: "# {mark} ANSIBLE MANAGED - Kubernetes environment PATH"
    block: |
      export PATH="/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin:$PATH"
    create: yes
  become: yes

- name: Configure kubectl completion and aliases in root bashrc
  blockinfile:
    path: /root/.bashrc
    marker: "# {mark} ANSIBLE MANAGED - Kubernetes aliases"
    block: |
      # kubectl completion
      if [ -f /etc/bash_completion.d/kubectl ]; then
        source /etc/bash_completion.d/kubectl
      fi

      # kubectl aliases
      alias k=kubectl
      alias kgp='kubectl get pods'
      alias kgs='kubectl get svc'
      alias kgn='kubectl get nodes'
      alias kga='kubectl get all'
      alias kgpa='kubectl get pods -A'
      complete -F __start_kubectl k
    create: yes
  become: yes
